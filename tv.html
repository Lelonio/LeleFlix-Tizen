<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=1920, initial-scale=1.0 maximum-scale=1.0  user-scalable=no" >
  <meta name="theme-color" content="#e50914">

  <title>LeleFlix</title>
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script src="https://luke-chang.github.io/js-spatial-navigation/spatial_navigation.js"></script>  

<style>
/* Sostituisci tutto il CSS esistente per la griglia con: */
.episode-selection-view {
  width: 100%;
  padding: 20px;
}

.episodes-container-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 10px;
  width: 100%;
}

/* Forza il layout su Tizen TV */
@media (orientation: landscape) {
  .episodes-container-grid {
    grid-template-columns: repeat(4, minmax(250px, 1fr));
  }
}

/* Stile per le card degli episodi */
.episode-card {
  background: var(--gray);
  border-radius: 8px;
  overflow: hidden;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
  cursor: pointer;
  display: flex;
  flex-direction: column;
}

.episode-card:hover {
  transform: scale(1.03);
  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.episode-card img {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
  object-fit: cover;
}

.episode-info {
  padding: 1rem;
  flex-grow: 1;
}

.episode-info h3 {
  margin-bottom: 0.5rem;
  font-size: 1.1rem;
}

.episode-meta {
  display: flex;
  justify-content: space-between;
  font-size: 0.85rem;
  color: var(--light-gray);
  margin-top: 0.5rem;
}

/* Placeholder per episodi senza immagine */
.episode-placeholder {
  background: var(--darker);
  aspect-ratio: 16/9;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--light-gray);
}
  /* Base Styles */
  :root {
    --primary: #e50914;
    --primary-dark: #b2070f;
    --dark: #141414;
    --darker: #0a0a0a;
    --gray: #222;
    --light-gray: #8c8c8c;
    --white: #fff;
    --transition: transform 0.3s ease;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background-color: var(--darker);
    color: var(--white);
    font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Navbar */
  .navbar {
    height: 80px;
    padding: 0 4%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: linear-gradient(180deg, rgba(229, 9, 20, 0.75) 0%, rgba(10, 10, 10, 0) 64%);
  }

  .logo {
    cursor: pointer;
    transition: transform 0.3s ease;
    height: 45px;
    width: auto;
  }

  .logo:hover {
    transform: scale(1.05);
  }

  /* Main Content */
  .main-content {
    padding-top: 50px;
    scroll-behavior: smooth;
    overscroll-behavior-y: contain;
    position: relative;
    z-index: 1;
  }

  /* Search Section */
  .search-section {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 4%;
    text-align: center;
  }

  .search-title {
    font-size: 2.5rem;
    font-weight: 800;
    margin-bottom: 1.5rem;
    line-height: 1.1;
  }

  .search-container {
    width: 100%;
    max-width: 600px;
    position: relative;
  }

  .search-input {
    width: 100%;
    padding: 15px 20px;
    font-size: 1.1rem;
    border: none;
    border-radius: 30px;
    background: rgba(255,255,255,0.1);
    color: white;
    transition: var(--transition);
    backdrop-filter: blur(10px);
  }

  .search-input:focus {
    outline: none;
    background: rgba(255,255,255,0.2);
    box-shadow: 0 0 15px rgba(229, 9, 20, 0.3);
  }

  .search-button {
    position: absolute;
    right: 15px;
    top: 30%;
    background: transparent;
    border: none;
    color: var(--white);
    font-size: 1.2rem;
    cursor: pointer;
  }

  /* Rows Container */
  .rows-container {
    padding: 0 4%;
    margin-bottom: 3rem;
    scroll-margin-top: 100px;
    padding: 20px 0;
  }

  .row-title {
    font-size: 1.4rem;
    margin-bottom: 1rem;
    margin-left: 50px;
    font-weight: 600;
    transition: transform 0.3s ease-out;
  }

  .rows-container:has(.row-item.tv-focused) .row-title {
    transform: translateX(10px);
    color: #e50914;
  }

  /* Row Items */
  .row {
    display: flex;
    overflow-x: auto;
    padding: 1rem 0;
    scroll-behavior: smooth;
    margin-left: 2%;
    margin-right: 2%;
    padding-left: 30px;
    scroll-snap-type: x mandatory;
    scroll-padding: 0 50px;
    overscroll-behavior-x: contain;
  }

  .row > * {
    margin-right: 30px;
  }

  .row::-webkit-scrollbar {
    display: none;
  }

  .row-item {
    flex: 0 0 auto;
    width: 16.666%;
    min-width: 200px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
    border-radius: 4px;
    overflow: hidden;
    aspect-ratio: 2/3;
    scroll-snap-align: start;
  }

  .row-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
    transition: opacity 0.3s ease;
  }

  .row-item:hover img {
    opacity: 0.7;
  }

  .row-item-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
    padding: 1.5rem 1rem 1rem;
    opacity: 1;
  }

  @media (hover: hover) and (pointer: fine) {
    .row-item-info {
      opacity: 0;
      transition: var(--transition);
    }
    
    .row-item:hover .row-item-info,
    .row-item:focus .row-item-info,
    .row-item.tv-focused .row-item-info {
      opacity: 1;
    }
  }

  .row-item-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .row-item-meta {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: var(--light-gray);
  }

  /* Focus Styles */
  .focusable:focus,
  .row-item:focus {
    outline: none;
    transform: scale(1.05);
    box-shadow: 0 0 0 3px #e50914;
    z-index: 10;
    
    transition: transform 0.2s ease;
  }

  .row-item:focus img{
    opacity: 0.5;
  }

  .row-item.tv-focused {
    transform: scale(1.05);

    
    z-index: 10;
    box-shadow: 0 0 5px 3px #e50914, 0 0 20px rgba(229, 9, 20, 0.5);
  }

  .search-input:focus,
  .search-button:focus {
    border-color: #e50914;
    color: #e50914;
    outline: none;
  }

  /* Search Results */
  .search-results {
    display: none;
    padding: 0 4% 2rem;
  }

  .search-results.active {
    display: block;
  }

  .search-results .row-title {
    font-size: 1.5rem;
    margin-bottom: 1.5rem;
  }

  /* Player Container */
  .player-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    z-index: 1000;
    display: none;
    justify-content: center;
    align-items: center;
  }

  .close-player {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(20, 20, 20, 0.7);
    border: 2px solid rgba(255, 255, 255, 0.5);
    color: white;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    font-size: 1.2rem;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 1001;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .close-player:hover {
    background: var(--primary);
    border-color: var(--primary);
    transform: scale(1.1);
  }

  /* Episode Selection */
  .episode-selection-view {
    width: 90%;
    max-width: 1200px;
    height: 90vh;
    overflow-y: auto;
    padding: 2rem;
    background: var(--dark);
    border-radius: 8px;
  }

  .series-header {
    display: flex;
    margin-bottom: 30px;
    align-items: flex-start;
  }

  .series-header > *:not(:last-child) {
    margin-right: 20px;
  }

  .series-poster {
    width: 200px;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  .series-info {
    flex: 1;
  }

  .series-overview {
    color: #aaa;
    margin-top: 10px;
    line-height: 1.5;
  }

  .seasons-title {
    margin: 20px 0;
    font-size: 1.5rem;
  }

.episodes-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));

}

  .episodes-grid > * {
    margin-top: 20px;
    margin-right: 20px;
  }

  

  .season-card {
    background: var(--gray);
    border-radius: 8px;
    overflow: hidden;
    transition: transform 0.3s ease;
    cursor: pointer;
  }

  .season-card:hover, 
  .season-card:focus {
    transform: scale(1.05);
  }

  .season-card:focus {
    outline: none;
    box-shadow: 0 0 0 3px var(--primary);
  }

  .season-poster {
    width: 100%;
    height: auto;
    aspect-ratio: 2/3;
    object-fit: cover;
  }

  .season-info {
    padding: 1rem;
  }

  .season-info h4 {
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
  }

  .season-info p {
    color: var(--light-gray);
    font-size: 0.9rem;
    margin: 0.2rem 0;
  }

  .episode-card {
    background: var(--gray);
    padding: 1rem;
    border-radius: 8px;
    cursor: pointer;
    transition: transform 0.3s ease;
    overflow: hidden;
  }

  .episode-card:hover {
    transform: translateY(-5px);
    background: var(--primary);
  }

  .episode-card img {
    width: 100%;
    height: auto;
    border-radius: 4px;
    margin-top: 0.5rem;
    object-fit: cover;
    aspect-ratio: 16/9;
  }

  /* States */
  .state-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    padding: 2rem;
    font-size: 1.2rem;
    color: var(--light-gray);
    width: 100%;
    max-width: 600px;
  }

  /* Responsive */
  
</style>
</head>
<body>
  <!-- Navbar -->
<nav class="navbar" id="navbar">
  <img src="logo.png" alt="Logo" class="logo" onclick="goToHome()">
</nav>

  <!-- Main Content -->
  <div class="main-content">
    <!-- Search Section -->
    <section class="search-section">
      <h1 class="search-title">Cosa vuoi guardare oggi?</h1>
      <div class="search-container">
        <input 
          type="text" 
          class="search-input focusable" 
          id="search-input" 
          placeholder="Cerca film, serie TV..."
          onkeyup="handleSearchKeyup(event)"
          tabindex="0"
        >
        <button class="search-button focusable" tabindex="0" onclick="searchMedia()">
          <i class="fas fa-search"></i>
        </button>
      </div>
    </section>

<div id="trending-container"></div>

    

    <!-- Search Results -->
    <div id="search-results" class="search-results">
      <h2 class="row-title">Risultati della ricerca</h2>
      <div class="row" id="results-container"></div>
    </div>
  </div>

<div class="player-container" id="player-container"></div>

  <script>
// Polyfill per scroll-behavior smooth
if (!('scrollBehavior' in document.documentElement.style)) {
  (function() {
    function smoothScrollPolyfill() {
      const originalScrollTo = Element.prototype.scrollTo;
      Element.prototype.scrollTo = function(options) {
        if (options && options.behavior === 'smooth') {
          const start = this.scrollLeft;
          const change = options.left - start;
          const startTime = performance.now();
          const duration = 300;

          const animateScroll = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            this.scrollLeft = start + change * progress;
            
            if (progress < 1) {
              requestAnimationFrame(animateScroll);
            }
          };
          
          requestAnimationFrame(animateScroll);
        } else {
          originalScrollTo.apply(this, arguments);
        }
      };
    }
    
    if (document.readyState === 'complete') {
      smoothScrollPolyfill();
    } else {
      window.addEventListener('load', smoothScrollPolyfill);
    }
  })();
}

// Polyfill per scroll-behavior smooth
if (!('scrollBehavior' in document.documentElement.style)) {
  (function() {
    function smoothScrollPolyfill() {
      const originalScrollTo = window.scrollTo;
      window.scrollTo = function(options) {
        if (options && options.behavior === 'smooth') {
          const start = window.pageYOffset;
          const change = options.top - start;
          const startTime = performance.now();
          const duration = 300;

          const animateScroll = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            window.scrollTo(0, start + change * progress);
            
            if (progress < 1) {
              requestAnimationFrame(animateScroll);
            }
          };
          
          requestAnimationFrame(animateScroll);
        } else {
          originalScrollTo.apply(this, arguments);
        }
      };
    }
    
    if (document.readyState === 'complete') {
      smoothScrollPolyfill();
    } else {
      window.addEventListener('load', smoothScrollPolyfill);
    }
  })();
}
</script>


  
  <script>



  document.addEventListener('DOMContentLoaded', function() {
  
  
});
let playerSessionToken = null;

// Aggiungi questo in cima allo script
let availableContent = [];

// Carica tutti i contenuti disponibili
async function loadAvailableContent() {
  try {
    const response = await fetch('https://api.leleflix.store/home/available');
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    
    const data = await response.json();
    availableContent = [...data.movies, ...data.tv];
    // console.log('Loaded available content:', availableContent.length);
    
    if (availableContent.length === 0) {
      console.warn('Nessun contenuto disponibile trovato');
    }
    
  } catch (error) {
    console.error('Error loading available content:', error);
    availableContent = [];
    
    // Mostra messaggio all'utente se necessario
    const errorEl = document.createElement('div');
    errorEl.className = 'bg-red-900 text-white p-4 rounded mb-4';
    errorEl.innerHTML = `
      <p>Errore nel caricamento dei contenuti disponibili</p>
      <p class="text-sm">${error.message}</p>
    `;
    document.querySelector('main').prepend(errorEl);
  }
}




function goToHome() {
    // Rimuovi classi di focus residue
    document.querySelectorAll('.tv-focused').forEach(el => {
        el.classList.remove('tv-focused');
        el.blur();
    });

    // Nascondi i risultati di ricerca
    document.getElementById("search-results").style.display = 'none';
    
    // Mostra la sezione trending
    document.getElementById("trending-container").style.display = 'block';
    
    // Resetta il campo di ricerca
    document.getElementById("search-input").value = '';
    
    // Scrolla in cima alla pagina
    window.scrollTo({ top: 0, behavior: 'smooth' });
    
    // Pulisci lo stack di modali (se ha senso semplificare lo stato globale)
    if (navigation && navigation.stateStack) {
        navigation.stateStack = [];
    }

    // Forza refresh dei focusable e imposta il primo
    if (navigation) {
        navigation.updateAfterContentLoad();
    }
}

function closeModalUI() {
    var playerContainer = document.getElementById("player-container");
    if (!playerContainer) return;

    // 1. Se per qualche motivo c'è un video aperto (es. se la modale è sovrapposta
    // a un player) lo puliamo, ma NON distruggiamo HLS se non serve:
    if (window.hls) {
        try {
            window.hls.destroy();
        } catch (e) {
            console.warn('Errore distruggendo hls in closeModalUI:', e);
        }
        window.hls = null;
    }
    var video = playerContainer.querySelector('video');
    if (video) {
        video.pause();
        video.removeAttribute('src');
        video.load();
    }

    // 2. Nascondi / svuota la UI della modale
    playerContainer.innerHTML = '';
    playerContainer.style.display = 'none';

    // 3. Ripristina il focus precedente se presente
    var prevId = playerContainer.dataset.previousFocus;
    if (prevId) {
        var prevEl = document.getElementById(prevId);
        if (prevEl) {
            try {
                prevEl.focus();
                // console.log('Focus ripristinato su elemento precedente:', prevEl);
            } catch (e) {
                console.warn('Impossibile ripristinare il focus precedente:', e);
            }
        }
        delete playerContainer.dataset.previousFocus;
    }

    // 4. Aggiorna navigazione
    if (typeof navigation !== 'undefined' && navigation) {
        if (typeof navigation.refreshFocusableElements === 'function') {
            navigation.refreshFocusableElements();
        }
        // Fallback: se esiste helper per il primo elemento
        if (typeof navigation.focusFirstElement === 'function') {
            navigation.focusFirstElement();
        } else if (typeof navigation.focusElement === 'function') {
            // prova a rifocalizzare l'indice corrente (se valido)
            navigation.focusElement(navigation.currentIndex || 0);
        }
    }
}


    // Load trending content
window.onload = async function() {
  try {
    // Prima carica i contenuti disponibili
    await loadAvailableContent();
    
    // Poi carica i contenuti trending e altre categorie
    await displayTrending('trending-movies-tv', 'Tendenze');
    await loadAdditionalCategories();
    
  } catch (e) {
    console.error("Errore caricamento dati:", e);
  }
};



function displayRow(items, id, title) {
  // Cerca il container principale
  let container = document.getElementById(id);
  
  // Se non esiste, crealo
  if (!container) {
    container = document.createElement('div');
    container.className = 'rows-container';
    container.id = id;
    document.querySelector('.main-content').appendChild(container);
  }

  // Crea o aggiorna il contenuto del container
  container.innerHTML = `
    <h2 class="row-title">${title}</h2>
    <div class="row" id="${id}-row"></div>
  `;

  const row = document.getElementById(`${id}-row`);
  
  // Verifica che la row esista prima di impostare innerHTML
  if (!row) {
    console.error(`Elemento row non trovato: ${id}-row`);
    return;
  }

  row.innerHTML = items.map(item => {
    const isTV = !!item.first_air_date;
    const posterPath = item.poster_path ? item.poster_path : '';
    const poster500 = posterPath ? `https://image.tmdb.org/t/p/w500${posterPath}` : '';
    const posterOriginal = posterPath ? `https://image.tmdb.org/t/p/original${posterPath}` : '';
    
    const svgFallback = `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 300'%3E%3Crect width='200' height='300' fill='%23333'/%3E%3Ctext x='100' y='150' text-anchor='middle' fill='%23fff' font-family='Arial' font-size='14'%3E${encodeURIComponent(isTV ? item.name : item.title)}%3C/text%3E%3C/svg%3E`;

    return `
      <div class="row-item focusable" tabindex="0" 
           onclick="${isTV ? 'showTVSeasons' : 'watchMovie'}(${item.id}, '${isTV ? 'tv' : 'movie'}')"
           data-poster="${posterOriginal || svgFallback}">
        <img src="${poster500 || svgFallback}" 
             data-src="${posterOriginal || svgFallback}" 
             alt="${isTV ? item.name : item.title}" 
             loading="lazy"
             onerror="this.src='${svgFallback}'">
        <div class="row-item-info">
          <h3 class="row-item-title">${isTV ? item.name : item.title}</h3>
          <div class="row-item-meta">
            <span>${isTV ? 'Serie TV' : 'Film'}</span>
            <span>${(isTV ? item.first_air_date : item.release_date) ? (isTV ? item.first_air_date : item.release_date).substring(0, 4) : 'N/D'}</span>
          </div>
        </div>
      </div>
    `;
  }).join('');

  // Aggiorna la navigazione
  if (navigation) {
    navigation.updateAfterContentLoad();
  }
}

            function handleSearchKeyup(event) {
            if (event.key === 'Enter') {
                searchMedia();
            }
            // 🔥 Aggiorna navigazione per gestire eventuali cambiamenti nella UI
            if (navigation && event.key === 'Escape') {
                // Se premuto Escape, torna ai trending
                const trendingContainer = document.getElementById("trending-container");
                const searchResults = document.getElementById("search-results");
                const searchInput = document.getElementById("search-input");
                
                searchInput.value = '';
                trendingContainer.style.display = 'block';
                searchResults.style.display = 'none';
                
                navigation.updateAfterContentLoad();
            }
        }
window.addEventListener('keydown', function (e) {
    const TIZEN_BACK_KEY = 10009; // codice tipico per "back" su Tizen
    if (e.keyCode === TIZEN_BACK_KEY) {
        // intercetta, ma fai la logica custom in modo pulito
        e.preventDefault(); // solo se vuoi sopprimere il comportamento di default
        if (typeof navigation !== 'undefined' && navigation) {
            navigation.handleBack();
        }
        // forzi il rilascio dello scroll dopo un breve delay (garantisce che UI sia aggiornata)
        setTimeout(() => {
            enableScroll();
        }, 50);
    }
});

// Sistema di navigazione ottimizzato specificamente per Tizen TV (versione ES5)
function TizenNavigation() {
    this.focusableElements = [];
    this.currentIndex = 0;
    this.isInitialized = false;
    this.isScrolling = false;
    this.lastScrollTime = 0;
    this.scrollDuration = 300;
    
    this.init();
    this.setupScrollHandlers();
    // Dentro il costruttore o come proprietà:
this.stateStack = [];

}

// Metodo init
TizenNavigation.prototype.init = function() {
    // Aspetta che il DOM sia completamente caricato
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', this.setup.bind(this));
    } else {
        this.setup();
    }
};

TizenNavigation.prototype.pushState = function(state) {
    this.stateStack.push(state);
};

TizenNavigation.prototype.popState = function() {
    return this.stateStack.pop();
};

TizenNavigation.prototype.peekState = function() {
    return this.stateStack[this.stateStack.length - 1];
};


// Metodo setup
TizenNavigation.prototype.setup = function() {
    // console.log('🔥 Inizializzando navigazione Tizen TV');
    
    // Gestisci eventi tastiera per navigazione con priorità alta
    document.addEventListener('keydown', this.handleKeyDown.bind(this), true);
    
    // Forza la disabilitazione della navigazione nativa Tizen
    this.disableTizenNativeNavigation();
    
    // Inizializza elementi focusable con delay per permettere il rendering
    var self = this;
    setTimeout(function() {
        self.refreshFocusableElements();
        self.focusFirstElement();
        self.isInitialized = true;
    }, 200);
};

// Metodo disableTizenNativeNavigation
TizenNavigation.prototype.disableTizenNativeNavigation = function() {
    // Disabilita la navigazione spaziale nativa di Tizen
    try {
        // Rimuovi attributi di navigazione spaziale nativi
        var elements = document.querySelectorAll('[spatial-navigation-action]');
        Array.prototype.forEach.call(elements, function(el) {
            el.removeAttribute('spatial-navigation-action');
        });
        
        // Disabilita focus automatico
        document.body.setAttribute('spatial-navigation', 'none');
        
        // console.log('✅ Navigazione nativa Tizen disabilitata');
    } catch (e) {
        console.warn('Impossibile disabilitare navigazione nativa:', e);
    }
};

// Metodo handleKeyDown
TizenNavigation.prototype.handleKeyDown = function(event) {
    if (!this.isInitialized) return;
    
    var keyCode = event.keyCode;
    
    // Intercetta TUTTI i tasti di navigazione prima che Tizen li gestisca
    if ([37, 38, 39, 40, 13, 27, 461, 10009].includes(keyCode)) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
    }

    //// console.log('🎮 Tasto premuto:', keyCode);

    switch(keyCode) {
        case 37: // Freccia sinistra
            this.navigateLeft();
            break;
        case 39: // Freccia destra  
            this.navigateRight();
            break;
        case 38: // Freccia su
            this.navigateUp();
            break;
        case 40: // Freccia giù
            this.navigateDown();
            break;
        case 13: // Tizen Enter
            this.activateCurrentElement();
            break;
        case 27: // Back
        case 10009: // Tizen Back
            this.handleBack();
            break;
    }
};

// Metodo refreshFocusableElements
TizenNavigation.prototype.refreshFocusableElements = function() {
    // Trova tutti gli elementi focusable visibili con controlli più rigidi
    var elements = document.querySelectorAll('.focusable');
    this.focusableElements = Array.prototype.filter.call(elements, function(el) {
        var rect = el.getBoundingClientRect();
        var style = window.getComputedStyle(el);
        
        return (
            rect.width > 0 && 
            rect.height > 0 && 
            style.display !== 'none' && 
            style.visibility !== 'hidden' &&
            el.offsetParent !== null
        );
    });
    
    // console.log('🎯 Elementi focusable trovati:', this.focusableElements.length, this.focusableElements);
    
    // Se l'indice corrente è fuori range, resettalo
    if (this.currentIndex >= this.focusableElements.length) {
        this.currentIndex = 0;
    }
};

// Metodo focusFirstElement
TizenNavigation.prototype.focusFirstElement = function() {
    if (this.focusableElements.length > 0) {
        this.focusElement(2);
        // console.log('👆 Focus iniziale impostato');
    }
};

// Metodo focusElement
TizenNavigation.prototype.focusElement = function(index) {
    if (index < 0 || index >= this.focusableElements.length) return;

    // Rimuovi focus precedente
    var previousElement = this.focusableElements[this.currentIndex];
    if (previousElement) {
        previousElement.blur();
        previousElement.classList.remove('tv-focused');
    }

    this.currentIndex = index;
    var element = this.focusableElements[this.currentIndex];

    if (element) {
        element.focus();
        element.classList.add('tv-focused');
        
        // Se stiamo tornando al primo elemento, assicurati che l'header sia visibile
        if (index === 0) {
            this.ensureHeaderVisible();
        } else {
            // Altrimenti, scrolla normalmente alla riga
            this.scrollToRow(element);
        }
        
        // Scroll orizzontale nella riga
        this.scrollIntoViewForTizen(element);
    }
};

// Metodo setupScrollHandlers
TizenNavigation.prototype.setupScrollHandlers = function() {
    var lastScrollPosition = 0;
    var self = this;
    
    window.addEventListener('scroll', function() {
        var currentScrollPosition = window.pageYOffset;
        var navbar = document.querySelector('.navbar');
        
        if (currentScrollPosition > lastScrollPosition && currentScrollPosition > 100) {
            // Scrolling down
            if (navbar) navbar.classList.add('hidden');
        } else {
            // Scrolling up
            if (navbar) navbar.classList.remove('hidden');
        }
        
        lastScrollPosition = currentScrollPosition;
    });
};

// Metodo scrollIntoViewForTizen
TizenNavigation.prototype.scrollIntoViewForTizen = function(element) {
    // Scroll ottimizzato per Tizen TV con animazione fluida
    var row = element.closest('.row');
    if (!row) return;

    var rowRect = row.getBoundingClientRect();
    var elementRect = element.getBoundingClientRect();
    var rowScrollLeft = row.scrollLeft;
    var rowWidth = row.clientWidth;
    
    // Calcola la posizione desiderata
    var elementLeft = elementRect.left - rowRect.left + rowScrollLeft;
    var elementRight = elementRect.right - rowRect.left + rowScrollLeft;
    var targetPosition = elementLeft - (rowWidth / 2) + (elementRect.width / 2);
    
    // Applica lo scroll con animazione
    row.scrollTo({
        left: targetPosition,
        behavior: 'smooth'
    });
    
    // Fallback per browser che non supportano scroll-behavior smooth
    if (!('scrollBehavior' in document.documentElement.style)) {
        var start = rowScrollLeft;
        var change = targetPosition - start;
        var startTime = performance.now();
        var duration = 300; // ms
        
        var self = this;
        var animateScroll = function(currentTime) {
            var elapsed = currentTime - startTime;
            var progress = Math.min(elapsed / duration, 1);
            row.scrollLeft = start + change * progress;
            
            if (progress < 1) {
                requestAnimationFrame(animateScroll);
            }
        };
        
        requestAnimationFrame(animateScroll);
    }
};

// Metodo navigateLeft
TizenNavigation.prototype.navigateLeft = function() {
    var current = this.focusableElements[this.currentIndex];
    if (!current) return;

    // console.log('⬅️ Navigazione sinistra');

    // Se siamo in una row, naviga nella stessa row
    if (current.closest('.row')) {
        var rowItems = Array.prototype.slice.call(current.closest('.row').querySelectorAll('.focusable'));
        var currentRowIndex = rowItems.indexOf(current);
        
        if (currentRowIndex > 0) {
            var newElement = rowItems[currentRowIndex - 1];
            var globalIndex = this.focusableElements.indexOf(newElement);
            if (globalIndex !== -1) {
                this.focusElement(globalIndex);
                return;
            }
        }
    }
    
    // Navigazione generale - vai al precedente
    if (this.currentIndex > 0) {
        this.focusElement(this.currentIndex - 1);
    }
};

// Metodo navigateRight
TizenNavigation.prototype.navigateRight = function() {
    var current = this.focusableElements[this.currentIndex];
    if (!current) return;

    // console.log('➡️ Navigazione destra');

    // Se siamo in una row, naviga nella stessa row
    if (current.closest('.row')) {
        var rowItems = Array.prototype.slice.call(current.closest('.row').querySelectorAll('.focusable'));
        var currentRowIndex = rowItems.indexOf(current);
        
        if (currentRowIndex < rowItems.length - 1) {
            var newElement = rowItems[currentRowIndex + 1];
            var globalIndex = this.focusableElements.indexOf(newElement);
            if (globalIndex !== -1) {
                this.focusElement(globalIndex);
                return;
            }
        }
    }
    
    // Navigazione generale - vai al successivo
    if (this.currentIndex < this.focusableElements.length - 1) {
        this.focusElement(this.currentIndex + 1);
    }
};

// Metodo ensureHeaderVisible
TizenNavigation.prototype.ensureHeaderVisible = function() {
    var navbar = document.querySelector('.navbar');
    if (!navbar) return;

    var navbarRect = navbar.getBoundingClientRect();
    
    // Se la navbar non è completamente visibile
    if (navbarRect.top < 0 || navbarRect.bottom > window.innerHeight) {
        this.smoothScrollTo(0); // Scrolla fino in cima
    }
};

// Metodo navigateUp
TizenNavigation.prototype.navigateUp = function() {
    var current = this.focusableElements[this.currentIndex];
    if (!current) return;

    // Se siamo già in cima alla pagina
    if (window.pageYOffset <= 0 && this.currentIndex === 0) {
        return; // Non fare nulla se siamo già in cima
    }

    var currentRect = current.getBoundingClientRect();
    var bestMatch = null;
    var bestDistance = Infinity;
    var self = this;

    // Cerca elementi sopra quello corrente
    for (var i = 0; i < this.focusableElements.length; i++) {
        var element = this.focusableElements[i];
        if (i === this.currentIndex) continue;
        
        var rect = element.getBoundingClientRect();
        
        if (rect.bottom <= currentRect.top + 10) {
            var distance = Math.abs(rect.left - currentRect.left) + (currentRect.top - rect.bottom);
            if (distance < bestDistance) {
                bestDistance = distance;
                bestMatch = i;
            }
        }
    }

    if (bestMatch !== null) {
        this.focusElement(bestMatch);
        this.scrollToRow(this.focusableElements[bestMatch]);
    } else {
        // Se non ci sono elementi sopra, scrolla in cima alla pagina
        if (this.currentIndex > 0) {
            this.focusElement(0);
            this.smoothScrollTo(0); // Scrolla fino in cima
        }
    }
};

// Metodo scrollToRow
TizenNavigation.prototype.scrollToRow = function(element) {
    var now = Date.now();
    if (now - this.lastScrollTime < this.scrollDuration) return;
    this.lastScrollTime = now;

    var navbar = document.querySelector('.navbar');
    var navbarHeight = navbar ? navbar.offsetHeight : 0;
    var target = element.closest('.rows-container');
    
    if (!target) return;

    var targetPosition = target.getBoundingClientRect().top + window.pageYOffset;
    var offsetPosition = targetPosition - navbarHeight - 20; // 20px di margine

    // Animazione personalizzata per maggiore fluidità
    this.smoothScrollTo(offsetPosition);
};

// Metodo smoothScrollTo
TizenNavigation.prototype.smoothScrollTo = function(targetPosition) {
    var startPosition = window.pageYOffset;
    var distance = targetPosition - startPosition;
    
    // Se la distanza è piccola, non animare
    if (Math.abs(distance) < 5) {
        window.scrollTo(0, targetPosition);
        return;
    }

    var startTime = performance.now();
    var duration = Math.min(Math.abs(distance) * 0.5, 100); // Durata massima 800ms

    var easeOutCubic = function(t) { return (--t) * t * t + 1; }; // Curva di easing più morbida
    var self = this;

    var animationFrame = function(currentTime) {
        var elapsed = currentTime - startTime;
        var progress = Math.min(elapsed / duration, 1);
        var easedProgress = easeOutCubic(progress);
        
        window.scrollTo(0, startPosition + distance * easedProgress);
        
        if (progress < 1) {
            requestAnimationFrame(animationFrame);
        }
    };

    requestAnimationFrame(animationFrame);
};

// Metodo navigateDown
TizenNavigation.prototype.navigateDown = function() {
    var current = this.focusableElements[this.currentIndex];
    if (!current) return;

    var currentRect = current.getBoundingClientRect();
    var bestMatch = null;
    var bestDistance = Infinity;
    var self = this;

    // Cerca elementi sotto quello corrente
    for (var i = 0; i < this.focusableElements.length; i++) {
        var element = this.focusableElements[i];
        if (i === this.currentIndex) continue;
        
        var rect = element.getBoundingClientRect();
        
        if (rect.top >= currentRect.bottom - 10) { // 10px di tolleranza
            var distance = Math.abs(rect.left - currentRect.left) + (rect.top - currentRect.bottom);
            if (distance < bestDistance) {
                bestDistance = distance;
                bestMatch = i;
            }
        }
    }

    if (bestMatch !== null) {
        this.focusElement(bestMatch);
        this.scrollRowIntoView(this.focusableElements[bestMatch]);
    } else if (this.currentIndex < this.focusableElements.length - 1) {
        this.focusElement(this.currentIndex + 1);
        this.scrollRowIntoView(this.focusableElements[this.currentIndex + 1]);
    }
};

// Metodo scrollRowIntoView
TizenNavigation.prototype.scrollRowIntoView = function(element) {
    if (this.isScrolling) return;
    this.isScrolling = true;

    var rowContainer = element.closest('.rows-container');
    if (!rowContainer) {
        this.isScrolling = false;
        return;
    }

    var containerTop = rowContainer.getBoundingClientRect().top;
    var navbar = document.querySelector('.navbar');
    var navbarHeight = navbar ? navbar.offsetHeight : 0;
    var offset = navbarHeight + 20; // 20px di margine

    // Calcola la posizione di scroll
    var targetPosition = rowContainer.offsetTop - offset;

    // Scroll fluido
    window.scrollTo({
        top: targetPosition,
        behavior: 'smooth'
    });

    // Fallback per browser senza supporto a scroll-behavior
    if (!('scrollBehavior' in document.documentElement.style)) {
        var start = window.pageYOffset;
        var change = targetPosition - start;
        var startTime = performance.now();
        var duration = 300;
        var self = this;

        var animateScroll = function(currentTime) {
            var elapsed = currentTime - startTime;
            var progress = Math.min(elapsed / duration, 1);
            window.scrollTo(0, start + change * progress);
            
            if (progress < 1) {
                requestAnimationFrame(animateScroll);
            } else {
                self.isScrolling = false;
            }
        };
        
        requestAnimationFrame(animateScroll);
    } else {
        var self = this;
        setTimeout(function() {
            self.isScrolling = false;
        }, 300);
    }
};

// Metodo activateCurrentElement
TizenNavigation.prototype.activateCurrentElement = function() {
    var current = this.focusableElements[this.currentIndex];
    if (current) {
        // console.log('🔥 Attivazione elemento:', current);
        
        // Gestisci elementi nei modali
        if (current.closest('.episode-selection-view')) {
            // Simula click con diversi metodi per compatibilità Tizen
            var event = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            current.dispatchEvent(event);
            
            // Fallback se onclick è definito
            if (current.onclick) {
                current.onclick();
            }
            return;
        }
        
        // Comportamento normale per altri elementi
        if (current.click) {
            current.click();
        } else if (current.onclick) {
            current.onclick();
        } else {
            var event = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window
            });
            current.dispatchEvent(event);
        }
    }
};

function disableScroll() {
    document.body.style.overflow = 'hidden';
    document.documentElement.style.overflow = 'hidden';
}

function enableScroll() {
    document.body.style.overflow = '';
    document.documentElement.style.overflow = '';
}


// Metodo handleBack
TizenNavigation.prototype.handleBack = function() {
    // console.log('🔙 Tasto Back premuto');

    // Se c'è uno stato in stack e è una modale, chiudi/modifica e ripristina focus
    const top = this.peekState();
    if (top && top.type === 'modal') {
        // Chiudi la modale (astratto: dipende da come apri/chiudi)
        closeModalUI(); // implementa questa funzione per chiudere visivamente il modal
      enableScroll();

        // Ripristina il focus precedente se esiste
        const prev = this.popState();
        if (prev && prev.previousElement) {
            const index = this.focusableElements.indexOf(prev.previousElement);
            if (index !== -1) {
                this.focusElement(index);
            } else {
                // Se non più presente, fallback al primo visibile
                this.focusFirstElement();
            }
        } else {
            this.focusFirstElement();
        }
        return;
    }

    // Fallback precedente: behavior su player/modali già gestiti
    var playerContainer = document.getElementById("player-container");
    if (playerContainer && playerContainer.style.display === 'flex') {
        var seasonsContainer = document.getElementById("seasons-container");
        var episodesContainer = document.getElementById("episodes-container");
        
        if (episodesContainer) {
            var tvId = episodesContainer.dataset.tvId;
            if (typeof showTVSeasons === 'function') {
                showTVSeasons(tvId, 'tv');
            }
            return;
        }
        
        if (seasonsContainer) {
            closePlayer();
            return;
        }
    }
};


// Metodo setupModalNavigation
TizenNavigation.prototype.setupModalNavigation = function() {
    var playerContainer = document.getElementById("player-container");
    if (!playerContainer || playerContainer.style.display !== 'flex') return;
    
    // Trova tutti gli elementi focusable nel modal
    var modalElements = playerContainer.querySelectorAll('.episode-card, .close-player');
    var modalFocusable = Array.prototype.filter.call(modalElements, function(el) {
        var style = window.getComputedStyle(el);
        return style.display !== 'none' && style.visibility !== 'hidden';
    });
    
    if (modalFocusable.length > 0) {
        // Combina con gli elementi esistenti
        this.focusableElements = modalFocusable;
        this.currentIndex = 0;
        this.focusElement(0);
    }
};

// Metodo updateAfterContentLoad
TizenNavigation.prototype.updateAfterContentLoad = function() {
    // console.log('🔄 Aggiornamento dopo caricamento contenuto dinamico');
    var self = this;
    
    // Aspetta che il rendering sia completato
    setTimeout(function() {
        var previousElement = self.focusableElements[self.currentIndex];
        self.refreshFocusableElements();
        
        // Se avevamo un elemento in focus, prova a mantenerlo o vai al primo disponibile
        if (self.focusableElements.length > 0) {
            var newIndex = 0;
            
            // Cerca di mantenere l'elemento precedentemente in focus
            if (previousElement) {
                var foundIndex = self.focusableElements.indexOf(previousElement);
                if (foundIndex !== -1) {
                    newIndex = foundIndex;
                } else {
                    // Se l'elemento precedente non esiste più, cerca il primo nella stessa sezione
                    var firstRowItem = document.querySelector('.row .focusable');
                    if (firstRowItem) {
                        var firstRowIndex = self.focusableElements.indexOf(firstRowItem);
                        if (firstRowIndex !== -1) {
                            newIndex = firstRowIndex;
                        }
                    }
                }
            }
            
            self.focusElement(newIndex);
        }
    }, 1000);
};

        // Inizializza il sistema di navigazione
        let navigation;
        document.addEventListener('DOMContentLoaded', () => {
            navigation = new TizenNavigation();
        });

        

        // Funzione migliorata per visualizzare i trending
// Funzione modificata per visualizzare i trending
async function displayTrending(containerId, title) {
  try {
    const trendingRes = await fetch('https://api.themoviedb.org/3/trending/all/day?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT');
    const trendingData = await trendingRes.json();
    
    // Filtra solo i contenuti disponibili
    const filteredTrending = trendingData.results.filter(item => 
      availableContent.some(content => content.tmdb_id === item.id)
    ).slice(0, 20);
    
    displayRow(filteredTrending, containerId, title);
  } catch (error) {
    console.error('Error loading trending content:', error);
    document.getElementById(containerId).innerHTML = `
      <div class="error-state">
        <i class="fas fa-exclamation-triangle"></i>
        <p>Errore nel caricamento dei contenuti in tendenza</p>
        <button onclick="displayTrending('${containerId}', '${title}')">Riprova</button>
      </div>
    `;
  }
}

// Funzione modificata per caricare categorie aggiuntive
async function loadAdditionalCategories() {
  try {
    // Popolari - solo quelli disponibili
    const popularRes = await fetch('https://api.themoviedb.org/3/movie/popular?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT');
    const popularData = await popularRes.json();
    const filteredPopular = popularData.results.filter(movie => 
      availableContent.some(content => content.tmdb_id === movie.id)
    ).slice(0, 20);
    displayRow(filteredPopular, 'popolari', 'Film popolari');
    
    // Serie TV in onda - solo quelle disponibili
    
    const onTheAirRes = await fetch('https://api.themoviedb.org/3/trending/tv/day?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT');
    const onTheAirData = await onTheAirRes.json();
    const filteredOnTheAir = onTheAirData.results.filter(tv => 
      availableContent.some(content => content.tmdb_id === tv.id)
    ).slice(0, 20);
    displayRow(filteredOnTheAir, 'serie-in-onda', 'Serie TV popolari');
    
    // Prossime uscite - solo quelle disponibili
    const upcomingRes = await fetch('https://api.themoviedb.org/3/movie/now_playing?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT');
    const upcomingData = await upcomingRes.json();
    const filteredUpcoming = upcomingData.results.filter(movie => 
      availableContent.some(content => content.tmdb_id === movie.id)
    ).slice(0, 20);
    displayRow(filteredUpcoming, 'prossime-uscite', 'Al cinema');
    
    // Altamente valutati - solo quelli disponibili
    const topRatedRes = await fetch('https://api.themoviedb.org/3/movie/top_rated?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT');
    const topRatedData = await topRatedRes.json();
    const filteredTopRated = topRatedData.results.filter(movie => 
      availableContent.some(content => content.tmdb_id === movie.id)
    ).slice(0, 20);
    displayRow(filteredTopRated, 'top-rated', 'Più votati');
    
  } catch (error) {
    console.error("Errore nel caricamento delle categorie:", error);
  }
}

    // Main search function
    async function searchMedia() {
        const query = document.getElementById("search-input").value.trim();
  const resultsContainer = document.getElementById("results-container");
  const trendingContainer = document.getElementById("trending-container");
  const searchResults = document.getElementById("search-results");

  if (!query) {
    trendingContainer.style.display = 'block';
    searchResults.style.display = 'none';
    if (navigation) navigation.updateAfterContentLoad();
    return;
  }

  trendingContainer.style.display = 'none';
  searchResults.style.display = 'block';

  resultsContainer.innerHTML = `
    <div style="width:100%; text-align:center; padding:40px;">
      <i class="fas fa-spinner loading-spinner"></i> Ricerca in corso...
    </div>
  `;
  
  if (navigation) navigation.updateAfterContentLoad();
  
  try {
    const searchResponse = await fetch(
      `https://api.themoviedb.org/3/search/multi?api_key=1e8c9083f94c62dd66fb2105cd7b613b&query=${encodeURIComponent(query)}&language=it-IT`
    );
    const searchData = await searchResponse.json();

    // Filtra solo i contenuti disponibili
    const allResults = (searchData.results || []).filter(item => 
      availableContent.some(content => content.tmdb_id === item.id) && 
      (item.media_type === 'movie' || item.media_type === 'tv')
    );

    if (allResults.length === 0) {
      resultsContainer.innerHTML = `
        <div style="width:100%; text-align:center; padding:40px;">
          <i class="far fa-sad-tear"></i> Nessun risultato trovato
        </div>
      `;
      if (navigation) navigation.updateAfterContentLoad();
      return;
    }

        resultsContainer.innerHTML = allResults.map(item => {
          const isTV = item.media_type === 'tv';
          const poster = item.poster_path 
            ? `https://image.tmdb.org/t/p/w500${item.poster_path}`
            : 'https://via.placeholder.com/500x750?text=No+poster';
          
          const year = isTV 
            ? (item.first_air_date ? item.first_air_date.substring(0, 4) : 'N/D')
            : (item.release_date ? item.release_date.substring(0, 4) : 'N/D');
          
          const title = isTV ? item.name : item.title;
          
          return `
      <div class="row-item focusable" tabindex="0" onclick="${isTV ? 'showTVSeasons' : 'watchMovie'}(${item.id}, '${isTV ? 'tv' : 'movie'}')">
        <img src="${poster}" alt="${title}" loading="lazy">
        <div class="row-item-info">
          <h3 class="row-item-title">${title}</h3>
          <div class="row-item-meta">
            <span>${isTV ? 'Serie TV' : 'Film'}</span>
            <span>${year}</span>
          </div>
        </div>
      </div>
    `;
  }).join('');

                // 🔥 Aggiorna navigazione anche in caso di errore
                if (navigation) {
                    navigation.updateAfterContentLoad();
                }

      } catch (error) {
        console.error("Search error:", error);
        resultsContainer.innerHTML = `
          <div style="width:100%; text-align:center; padding:40px;">
            <i class="fas fa-exclamation-triangle"></i> Errore durante la ricerca
            <button onclick="searchMedia()" style="
              margin-top: 15px;
              background: var(--primary);
              color: white;
              border: none;
              padding: 8px 15px;
              border-radius: 5px;
              cursor: pointer;
            ">
              Riprova
            </button>
          </div>
        `;
      }
    }






    // Show TV seasons selection
function showTVSeasons(tvId, type) {
    var playerContainer = document.getElementById("player-container");
        if (navigation) {
        navigation.pushState({
            type: 'modal',
            previousElement: navigation.focusableElements[navigation.currentIndex] || null
        });
    }
    // 1. Carica i dati della serie
    Promise.all([
        fetch('https://api.themoviedb.org/3/tv/' + tvId + '?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT'),
        fetch('https://api.themoviedb.org/3/tv/' + tvId + '/aggregate_credits?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT')
    ])
    .then(function(responses) {
        return Promise.all([responses[0].json(), responses[1].json()]);
    })
    .then(function(data) {
        var seriesData = data[0];
        var seasonsData = data[1];


        // 2. Crea il modale
        playerContainer.innerHTML = [
            '<div class="video-container" id="season-modal" style="justify-content: center; align-items: center; background: var(--dark);">',
                '<div class="episode-selection-view">',
                    '<div class="series-header">',
                        '<img src="', (seriesData.poster_path ? 'https://image.tmdb.org/t/p/w500' + seriesData.poster_path : 'placeholder-serie.svg'), '" ',
                             'alt="', seriesData.name, '" ',
                             'class="series-poster">',
                        '<div class="series-info">',
                            '<h2>', seriesData.name, '</h2>',
                            '<p class="series-overview">', (seriesData.overview || 'Nessuna descrizione disponibile'), '</p>',
                        '</div>',
                    '</div>',
                    '<h3 class="seasons-title">Seleziona Stagione</h3>',
                    '<div id="seasons-container" class="episodes-grid" data-tv-id="', tvId, '"></div>',
                '</div>',
            '</div>'
        ].join('');

        // 3. Popola le stagioni
        var seasonsContainer = document.getElementById("seasons-container");
        var seasonsHTML = seriesData.seasons.map(function(season) {
            var seasonPoster = season.poster_path 
                ? 'https://image.tmdb.org/t/p/w300' + season.poster_path
                : seriesData.poster_path 
                    ? 'https://image.tmdb.org/t/p/w300' + seriesData.poster_path
                    : 'placeholder-stagione.svg';

            return [
                '<div class="season-card focusable" tabindex="0" ',
                     'onclick="showEpisodes(', tvId, ', ', season.season_number, ')">',
                    '<img src="', seasonPoster, '" ',
                         'alt="Stagione ', season.season_number, '" ',
                         'loading="lazy" ',
                         'class="season-poster">',
                    '<div class="season-info">',
                        '<h4>Stagione ', season.season_number, '</h4>',
                        '<p>', season.episode_count, ' episodi</p>',
                        season.air_date ? '<p>' + season.air_date.substring(0, 4) + '</p>' : '',
                    '</div>',
                '</div>'
            ].join('');
        }).join('');

        seasonsContainer.innerHTML = seasonsHTML;

        // 4. Mostra il modale
        playerContainer.style.display = 'flex';
        document.body.style.overflow = 'hidden';

        // 5. Memorizza l'elemento attivo prima di aprire il modale
        var previousActiveElement = document.activeElement;
        if (previousActiveElement && previousActiveElement.id) {
            playerContainer.dataset.previousFocus = previousActiveElement.id;
        } else {
            playerContainer.dataset.previousFocus = '';
        }

        // 6. Aggiorna la navigazione SOLO con gli elementi del modale
        if (navigation) {
            var modal = document.getElementById('season-modal');
            navigation.focusableElements = Array.prototype.filter.call(
                modal.querySelectorAll('.focusable'),
                function(el) {
                    var style = window.getComputedStyle(el);
                    return style.display !== 'none' && style.visibility !== 'hidden';
                }
            );
            
            navigation.currentIndex = 0;
            navigation.focusElement(0);
        }
    })
    .catch(function(error) {
        console.error("Error loading seasons:", error);
        playerContainer.innerHTML = [
            '<div class="state-message">',
                '<i class="fas fa-exclamation-triangle"></i>',
                '<p>Errore nel caricamento delle stagioni</p>',
                '<button class="focusable" tabindex="0" onclick="showTVSeasons(', tvId, ', \'', type, '\')">Riprova</button>',
            '</div>'
        ].join('');
        
        if (navigation) {
            navigation.updateAfterContentLoad();
        }
    });
}

async function showEpisodes(tvId, seasonNumber) {
    const playerContainer = document.getElementById("player-container");
    const seasonsContainer = document.getElementById("seasons-container");
    
    playerContainer.innerHTML = `
        <div class="video-container" style="justify-content: center; align-items: center; background: var(--dark);">
            <div class="episode-selection-view">
                <h2>Stagione ${seasonNumber} - Seleziona Episodio</h2>
                <div id="episodes-container" class="episodes-grid" data-tv-id="${tvId}" data-season-number="${seasonNumber}"></div>
            </div>
        </div>
    `;
    
    try {
        const response = await fetch(`https://api.themoviedb.org/3/tv/${tvId}/season/${seasonNumber}?api_key=1e8c9083f94c62dd66fb2105cd7b613b&language=it-IT`);
        const data = await response.json();
        
        const episodesContainer = document.getElementById("episodes-container");
        episodesContainer.innerHTML =`
    <div class="episodes-container-grid"> <!-- Aggiungi questa classe -->
        ${data.episodes.map(episode => `
            <div class="episode-card focusable" tabindex="0" 
                 onclick="initAndPlayTVEpisode(${tvId}, ${seasonNumber}, ${episode.episode_number})"
                 onkeydown="if(event.key === 'Enter') initAndPlayTVEpisode(${tvId}, ${seasonNumber}, ${episode.episode_number})">
                <h3>Episodio ${episode.episode_number}</h3>
                <p>${episode.name || 'Senza titolo'}</p>
                ${episode.still_path ? `
                    <img src="https://image.tmdb.org/t/p/w300${episode.still_path}" 
                         alt="${episode.name || 'Episodio'}"
                         loading="lazy">` : ''}
                <div class="episode-meta">
                    <span>${episode.runtime ? episode.runtime + ' min' : 'Durata N/D'}</span>
                    <span>${episode.air_date ? new Date(episode.air_date).toLocaleDateString('it-IT') : 'Data N/D'}</span>
                </div>
            </div>
        `).join('')}
    </div>
`;
        
        playerContainer.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        
        // Aggiorna la navigazione per il modal
        if (navigation) {
            navigation.setupModalNavigation();
        }

        navigation.currentIndex = 0;
        navigation.focusElement(0);
        
    } catch (error) {
        console.error("Error loading episodes:", error);
        playerContainer.innerHTML = `
            <div class="state-message">
                <i class="fas fa-exclamation-triangle"></i>
                <p>Errore nel caricamento degli episodi</p>
                <button class="focusable" tabindex="0" onclick="showEpisodes(${tvId}, ${seasonNumber})">Riprova</button>
            </div>
        `;
    }
}

// Nuova funzione per inizializzare e poi riprodurre
function initAndPlayTVEpisode(tvId, seasonNumber, episodeNumber) {
    // Chiudi il player corrente se aperto
    
    // Apri il player esterno con i parametri della serie TV
    window.location.href = `player.html?tvId=${tvId}&season=${seasonNumber}&episode=${episodeNumber}&type=tv`;
}

// Watch movie using vixsrc with Netflix-style player and HLS.js
// Modifica le tue funzioni esistenti per usare il player esterno:

async function watchMovie(movieId, type) {
    // Chiudi il player corrente se aperto
    
    // Apri il player esterno con i parametri del film
    window.location.href = `player.html?movieId=${movieId}&type=movie`;
}
/**
 * Chiude il player modale e gestisce la pulizia delle risorse (ES5-compatibile)
 */
function closePlayer() {
    var playerContainer = document.getElementById("player-container");
    if (!playerContainer) return;
    
    // 1. Chiudi il player video se aperto
    if (window.hls) {
        window.hls.destroy();
        window.hls = null;
    }
    
    var video = playerContainer.querySelector('video');
    if (video) {
        video.pause();
        video.removeAttribute('src');
        video.load();
    }
    
    // 2. Pulisci i modali
    var episodeModal = document.getElementById("episodes-container");
    if (episodeModal && episodeModal.parentNode) {
        episodeModal.parentNode.removeChild(episodeModal);
    }
    
    var seasonsModal = document.getElementById("seasons-container");
    if (seasonsModal && seasonsModal.parentNode) {
        seasonsModal.parentNode.removeChild(seasonsModal);
    }
    
    // 3. Ripristina lo stato della pagina
    playerContainer.style.display = 'none';
    document.body.style.overflow = 'auto';
    
    // 4. Ripristino avanzato del focus
    var previousElement = null;
    
    // Prova a recuperare l'elemento direttamente
    if (playerContainer.dataset.previousElement) {
        previousElement = playerContainer.dataset.previousElement;
    } 
    // Fallback: recupera tramite ID
    else if (playerContainer.dataset.previousFocus) {
        previousElement = document.getElementById(playerContainer.dataset.previousFocus);
    }
    
    // Ripristina il focus se l'elemento esiste ancora nel DOM
    if (previousElement && document.body.contains(previousElement)) {
        try {
            previousElement.focus();
            // console.log('Focus ripristinato su:', previousElement);
        } catch (e) {
            console.warn('Impossibile ripristinare il focus:', e);
        }
    }
    
    // 5. Aggiorna la navigazione TV
    if (typeof navigation !== 'undefined' && navigation) {
        navigation.refreshFocusableElements();
        
        // Se non è stato possibile ripristinare il focus, fallback al primo elemento
        if (!previousElement || !document.body.contains(previousElement)) {
            navigation.focusElement(0);
        }
    }
}

// Listener per il tasto back/escape (ES5-compatibile)
document.addEventListener('DOMContentLoaded', function() {
    document.addEventListener('keydown', function(e) {
        var key = e.key || String.fromCharCode(e.keyCode);
        if (key === 'Backspace' || key === 'Escape' || e.keyCode === 27 || e.keyCode === 10009) {
            var playerContainer = document.getElementById("player-container");
            if (playerContainer && playerContainer.style.display === 'flex') {
                e.preventDefault();
                closePlayer();
            }
        }
    });
});
  </script>


</body>
</html>